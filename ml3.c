// ----------------------------------------------------------------------------
// Project:    IR Transmitter for Nikon DSLR Cameras
// Target:     Minimus USB (AT90USB162)
// Date:       11-APR-2012
// Author:     Simon Foster
// ----------------------------------------------------------------------------
// Revision:   1     First Release
// ----------------------------------------------------------------------------
//
//    Pin      Function          Comments
// ----------------------------------------------------------------------------
// WAVEFORM for Nikon ML-L3 remote control
// See http://www.bigmike.it/ircontrol/
// also http://www.fizzpop.org.uk/blog/nikon-dslr-ir-remote-project/
// 
// ON    2000us
// OFF   27830us
// ON    400us
// OFF   1580us
// ON    400us
// OFF   3580us
// ON    400us
//
// ----------------------------------------------------------------------------
//
// The ON state for the transmitter is a 38.4kHz square wave
// This is generated by a Timer Compare on Timer 0 which is left
// running permamnently while the signal is transmitted.
//    
// This signal is then modulated by turning the relevant port output
// ON and OFF.
//    
// The system clock used is the EXTERNAL 16MHz crystal but CKDIV8 is set
// so the clock frequency is 2MHz on power up
//    
// ----------------------------------------------------------------------------

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <util/delay.h>

// From Datasheet
// for CTC mode with output toogle at compare match
// f = f(CLK)/( 2 * N * ( 1 + OCR0A ))
// where N = prescaler value

#define FREQ( hz ) (( F_CPU / ( 2UL * 1 * (hz))) - 1 )

#define LED_OFF (DDRB &= ~_BV(PORTB7))       // Set PB.7 as input
#define LED_ON  (DDRB |= _BV(PORTB7))        // Set PB.7 as output

int main( void )
{
    // Timer is initialised to Mode 2 CTC(Clear Timer On Compare Match)
    // and the output is set to Toggle on each Compare Match.
    
    TCCR0A  = 0x42;                 // COM0A1:0 = 01    Toggle OC0A on compare match
                                    // COM0B1:0 = XX    Don't care
                                    // WGM01:00 = 2     Mode 2, CTC mode

    TCCR0B  = 0x01;                 // WGM02    = 0     Mode 2, See above
                                    // CS02:00  = 1     Clock running, No prescalar

    OCR0A   = FREQ(38400);          // Select output frequency
    
    _delay_ms( 1 );                 // Wait for everything to settle


	// Send sequence WAIT 63.2ms then REPEAT

    LED_ON;
    _delay_us( 2000 );
    LED_OFF;
    _delay_us( 27830 );
    LED_ON;
    _delay_us( 400 );
    LED_OFF;
    _delay_us( 1580 );
    LED_ON;
    _delay_us( 400 );
    LED_OFF;
    _delay_us( 3580 );
    LED_ON;
    _delay_us( 400 );
    LED_OFF;

    _delay_ms( 63 );

    LED_ON;
    _delay_us( 2000 );
    LED_OFF;
    _delay_us( 27830 );
    LED_ON;
    _delay_us( 400 );
    LED_OFF;
    _delay_us( 1580 );
    LED_ON;
    _delay_us( 400 );
    LED_OFF;
    _delay_us( 3580 );
    LED_ON;
    _delay_us( 400 );
    LED_OFF;
    
    while(1)
    {
        // Sleep until next reset
        // Prob should check that there's nothing else that
        // we should disable here to improve battery life

        DDRB = 0;           // Make sure all ports off before sleep
        PORTB = 0;			// Make sure pullups are turned off
    
        set_sleep_mode( SLEEP_MODE_PWR_DOWN );
        sleep_mode();
    }
}
